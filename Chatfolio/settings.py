"""
Django settings for Chatfolio project.

Generated by 'django-admin startproject' using Django 4.2.18.

For more information on this file, see
https://docs.djangoproject.com/en/4.2/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/4.2/ref/settings/
"""

from pathlib import Path
import os

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/4.2/howto/deployment/checklist/


'''
    Προσοχή: Αφαιρώ τους κωδικούς από το plain text settings.py και να εισάγω στο ασφαλέστερο .env
    Το .env είναι και αυτό plain text αλλά με τη ρύθμιση .gitignore δεν ανεβαίνει στο github
    SECURITY WARNING: keep the SECRET_KEY and the DEBUG used in production secret!
'''
from decouple import config
SECRET_KEY = config('MY_SECRET_KEY')
DEBUG = config('MY_DEBUG', default=False, cast=bool)
#SECRET_KEY = '.....'
#DEBUG = .....


if DEBUG:
    ALLOWED_HOSTS = ["localhost", "127.0.0.1"]
else:
    ALLOWED_HOSTS = ["localhost", "127.0.0.1"] # συμπληρώνω το δικό μου domain
    pass

# Application definition
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',

    'accounts_app',
    'chat_app',
    'compressor',
    'htmlmin',
    'rest_framework',
    'corsheaders',
    'webpack_loader',
]

WEBPACK_LOADER = {
    'DEFAULT': {
        'CACHE': not DEBUG,
        'BUNDLE_DIR_NAME': 'static/', # build/static/ react folder αποθηκεύει όλα τα js/css files
        'STATS_FILE': os.path.join(BASE_DIR, 'chat_app_react_frontend/build/webpack-stats.json'),
    }
}

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',

    'whitenoise.middleware.WhiteNoiseMiddleware',
    'htmlmin.middleware.HtmlMinifyMiddleware', # html minification
    'htmlmin.middleware.MarkRequestMiddleware', # html minification per request
    'corsheaders.middleware.CorsMiddleware', # Browser CORS Policy for Django-React communication

#   django app .      filename        .       class
    'chat_app.loginRequired_middleware.LoginRequiredMiddleware',
]


'''
    Σενάριο 1
    Η Django τρέχει σε localhost:8000 ενώ η React σε localhost:3000
    Για λόγους ασφαλείας, η CORS Policy ενός browser μπλοκάρει την επικοινωνία μεταξύ διαφορετικών origins {protocol+IP+post}
    Άρα, για να επικοινωνεί το react-frontend με το django-backend:
        α) φτιάχνω μια CORS Whitelist για το localhost:3000
        β) απαιτείται npm start

            if DEBUG: # http
                CORS_ALLOWED_ORIGINS = [
                    "http://localhost:3000",
                    "http://127.0.0.1:3000",
                ]
            else: # https
                CORS_ALLOWED_ORIGINS = [
                    "https://localhost:3000",
                    "https://127.0.0.1:3000",
                ]

    Σενάριο 2
    Η Django τρέχει σε localhost:8000 ενώ η React σερβίρεται ως django-template στο ίδιο localhost:8000
    Δηλαδή η react φορτώνεται ως static files από την django
    Συνεπώς:
        α) δεν απαιτείται npm start
        β) δεν απαιτείται Browser CORS Whitelist για το localhost:3000
'''
'''
if DEBUG: # http
    CORS_ALLOWED_ORIGINS = [
        "http://localhost:8000",
        "http://127.0.0.1:8000",
    ]
else: # https
    CORS_ALLOWED_ORIGINS = [
        "https://localhost:8000",
        "https://127.0.0.1:8000",
    ]
'''
CORS_ALLOWED_ORIGINS = [
    "http://localhost:5173",
]




ROOT_URLCONF = 'Chatfolio.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        # Αν υπάρχει φάκελος templates εκτός των apps, πρέπει να το δηλώσω για να ψάχνει και εκεί
        'DIRS': [
            BASE_DIR / 'templates', # django apps templates
            os.path.join(BASE_DIR, 'chat_app_react_frontend/build'), # react apps templates
            ],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]


WSGI_APPLICATION = 'Chatfolio.wsgi.application'


# Database
# https://docs.djangoproject.com/en/4.2/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}


# Password validation
# https://docs.djangoproject.com/en/4.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/4.2/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files: Αρχεία της εφαρμογής (πχ CSS, JavaScript, JSON, favicon)
# https://docs.djangoproject.com/en/4.2/howto/static-files/
STATIC_ROOT = BASE_DIR / 'productionStatic'
STATIC_URL = '/static/'
STATICFILES_DIRS = [
    BASE_DIR / 'static', # django static/ folders

    # Καλό είναι να ορίσω ολόκληρο το react build/ folder και όχι μόνο τον react static/ subfolder
    os.path.join(BASE_DIR, 'chat_app_react_frontend/build/'), # react build/ folder
]

# Media files: Αρχεία που ανεβάζουν οι χρήστες (πχ φωτογραφία προφίλ)
MEDIA_URL = '/media/'
MEDIA_ROOT = BASE_DIR / 'media'


# Default primary key field type
# https://docs.djangoproject.com/en/4.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'


# ΠΡΟΣΟΧΗ: Αν αυτό δηλωθεί μετά το πρώτο makemigrations θα πρέπει να ξαναχτίσω από την αρχή τη βάση δεδομένων
AUTH_USER_MODEL = 'accounts_app.MyUser'


# Για να κάνω login με email και όχι με username που είναι το django default
AUTHENTICATION_BACKENDS = [
    'accounts_app.backends.EmailBackend',
]


# Αυτή η σελίδα θα σερβίρεται αν κάποιος ζητήσει κάτι χωρίς να έχει κάνει login
LOGIN_URL = '/login/'


##################################### Ρυθμίσεις Ασφαλείας για τα Cookies
if DEBUG:
    SESSION_COOKIE_SECURE = False
    CSRF_COOKIE_SECURE = False
else:
    # Τα Cookies θα στέλνοται στους clients μόνο αν χρησιμοποιείται το πρωτόκολλο HTTPS
    SESSION_COOKIE_SECURE = True
    CSRF_COOKIE_SECURE = True
    
    # Force Redirect HTTP Requests σε HTTPS Requests
    #SECURE_SSL_REDIRECT = True

    # HSTS: Υποχρεωτική χρήση HTTPS (προαιρετικά)
    #SECURE_HSTS_SECONDS = 31536000  # 1 χρόνος
    #SECURE_HSTS_INCLUDE_SUBDOMAINS = True
    #SECURE_HSTS_PRELOAD = True


# Τα Cookies δε θα είναι προσβάσιμα από κώδικα JavaScript
SESSION_COOKIE_HTTPONLY = True
CSRF_COOKIE_HTTPONLY = True

# Τα cookies να μην μπορούν να κλαπούν από Cross Site Requests (δηλ requests που καταλήγουν σε κακόβουλα sites)
SESSION_COOKIE_SAMESITE = 'Lax' # 'Strict'
CSRF_COOKIE_SAMESITE = 'Lax' # 'Strict'

# Ημερομηνία λήξης των Cookies
SESSION_COOKIE_AGE = 60 * 60 * 24 * 7  # Το session cookie θα διαρκεί 1 εβδομάδα
SESSION_EXPIRE_AT_BROWSER_CLOSE = False # To session cookie δε θα διαγράφεται όταν κλείνει ο browser


##################################### Static Files Minification μέσω του django-compressor
STATICFILES_FINDERS = [
    'django.contrib.staticfiles.finders.FileSystemFinder', # ψάχνει static files στο BASE_DIR/static
    'django.contrib.staticfiles.finders.AppDirectoriesFinder', # ψάχνει static files στα apps/static
    'compressor.finders.CompressorFinder',
]

# Συμπιέζει τα static files και μάλιστα offline (δηλ. πριν εκκινήσει ο runserver) για ταχύτερη φόρτωση της σελίδας
COMPRESS_ENABLED = True
COMPRESS_OFFLINE = True

# Αφαιρεί περιττά κενά, σχόλια κλπ για να μειωθεί το μέγεθος των static files για ταχύτερη φόρτωση της σελίδας
COMPRESS_CSS_FILTERS = [
    'compressor.filters.cssmin.CSSMinFilter',
]

COMPRESS_JS_FILTERS = [
    'compressor.filters.jsmin.JSMinFilter',
]

# Το whitenoise συμπιέζει τα static files σε gzip και κάνει cache busting
STATICFILES_STORAGE = "whitenoise.storage.CompressedManifestStaticFilesStorage"

# Το {% compress %} block ενώνει όλα τα static files σε 1 μόνο και μετά εφαρμόζει minification
# Για κάθε static file στέλνεται ξεχωριστό HTTP Request/Response
# Άρα, καλό είναι να συγχωνεύω όσο δυνατόν περισσότερα css/js αρχεία μπορώ στο ίδιο {% compress %} block


#################################### HTML Minification μέσω του django-htmlmin
HTML_MINIFY = True
KEEP_COMMENTS_ON_MINIFYING = False  # Αφαιρεί τα σχόλια


'''
    Ρυθμίσεις για Ασφαλή Κρυπτογράφιση των κωδικών των χρηστών μέσα στη βάση δεδομένων
        Γενικά, το να αποθηκεύω το SHA256 δεν είναι καθόλου καλή πρακτική.
        Με μια μέτρια υπολογιστική ισχύ μπορεί κάποιος να παράξει εκατομμύρια hashes και να σπάσει κωδικούς με brute-force.

        Λύση
        Εφαρμόζω επαναληπτικά κρυπτογράφιση εκατομμύρια φορές ώστε να είναι πολύ χρονοβόρρα μια επίθεση brute-force.
        Επιπλέον, προσθέτω και λίγο αλάτι (salt) στον κωδικό του χρήστη, δηλ. ένα μοναδικό και τυχαίο string
        ώστε αν κάποιοι χρήστες έχουν ίδιο κωδικό πρόσβασης, τότε στη βάση δεδομένων να έχουν διαφορετικά hashes.

        Οι κωδικοί πρόσβασης αποθηκεύονται στη βάση δεδομένων ως εξής: encryption-algorithm $ iterations $ salt $ hash

        Έτσι, αποτέπω τις εξής επιθέσεις:
            1) Brute Force Attack:
            2) Rainbow Table Attack: Χρήση πινάκων με αντιστοιχίες μεταξύ password_plain_text και το αντίστοιχο hash_256

        Ο πιο ισχυρός από όλους είναι ο Argon2 μιας και κρυπτογραφεί καταναλώνοντας πάρα πολύ μνήμη και χρόνο εκτέλεσης
        Συνεπώς, μια Brute Force Attack θα πρέπει να καταναλώσει εξίσου τόσους πολλούς πόρους εις το πολλαπλάσιο για να σπάσει κωδικούς
'''
PASSWORD_HASHERS = [
    'django.contrib.auth.hashers.Argon2PasswordHasher',
    'django.contrib.auth.hashers.PBKDF2PasswordHasher',
    'django.contrib.auth.hashers.PBKDF2SHA1PasswordHasher',
    'django.contrib.auth.hashers.BCryptSHA256PasswordHasher',
]